[{"title":"Ant desgn Pro4.0 配置环境变量","date":"2019-11-07T07:50:22.000Z","path":"2019/11/07/blog-011/","text":"不少小伙伴工作中用的 react + ant 来开发。最新的后台管理模板更新到 Ant desgn Pro4.0，由于高度封装了，很多webpack 配置都傻瓜式了…最近遇到一个问题，一个前端在开发环境中需要对接5个Java 开发，这时候就出现问题了，对接不同人时的ip不同，难道每次修改配置文件连接？答案肯定不是，下边教你运用环境变量来解决这个多ip地址 问题 1.安装 cross-env123npm install cross-env --save-dev或者yarn add cross-env --dev 对于 npm 和 yarn 的介绍请移步 Npm vs Yarn 2.配置环境变量了解node的都知道，node默认有开发环境development和生产环境production两个变量，这里不过多讲述。回到问题来，在开发环境 NODE_ENV 默认是development，按照这个思路，我们加一个自己的变量比如：API_ENV 来定义不同ip 下的接口url。下边一步一步来配置： config.js 2.配置package.json 3.request.js 结语 以上是针对开发过程遇到具体问题的解决办法，因为限于时间和个人水平，实现方法可能很low，也希望有好的建议请分享出来供大家学习 大牛有好的建议请留言，先感谢您的建议！"},{"title":"Deeplearn.js入门","date":"2019-11-05T07:13:44.000Z","path":"2019/11/05/blog-010/","text":"1.简介deeplearn.js 是一款用于机器智能领域的基于硬件加速的JavaScript库。该库将高性能的机器学习构建模块引入到web 开发领域，允许我们在浏览器中训练神经网络模型或在推理模式下运行预训练的模型。该库提供了两个API模型：一个是立即执行模型（可认为是NumPy），另一个是基于TensorFlow API镜像的延期执行模型。deeplearn.js最初是由Google Brain PAIR团队开发的，目的是为了构建强大的基于浏览器的交互式机器学习工具，几乎可以被应用于任何领域，包括教育、模型理解、艺术项目等。 2.用法TypeScript/ES6 JavaScript1npm install deeplearn 该命令的作用是安装deeplearn的依赖包，在运行该命令之前，确保您的电脑上安装了node.js，去学习：npm &amp; yarn 一个简单的用标量求数组之和的例子： 123456789import &#123;Array1D, NDArrayMathGPU, Scalar&#125; from &apos;deeplearn&apos;;const math = new NDArrayMathGPU();const a = Array1D.new([1, 2, 3]);const b = Scalar.new(2);math.scope(() =&gt; &#123; const result = math.add(a, b); console.log(result.getValues()); // Float32Array([3, 4, 5])&#125;); ES3/ES5 JavaScript您也可以在普通的JavaScript平台上使用，直接从Google CDN上加载最新的版本库： 1`&lt;script src=&quot;https://storage.googleapis.com/learnjs-data/deeplearn-latest.js&quot;&gt;&lt;/script&gt; 您可以在 GitHub 的发布页寻找到特定的版本替换一个新的版本号（例如：deeplearn-0.1.0.js）。在导入该库后，可以在全局命名空间使用该API，名称为deeplearn： 1234567var math = new deeplearn.NDArrayMathGPU();var a = deeplearn.Array1D.new([1, 2, 3]);var b = deeplearn.Scalar.new(2);math.scope(function() &#123; var result = math.add(a, b); console.log(result.getValues()); // Float32Array([3, 4, 5])&#125;); 3.构建从源代码构建deeplearn.js，我们需要克隆该项目以准备好开发环境： 123$ git clone https://github.com/PAIR-code/deeplearnjs.git$ cd deeplearnjs$ npm run prep #安装node模块和bower组件。 我们需要用Visual Studio Code作为我们的开发工具。确保安装了 clang-format 命令行工具以及自动格式化工具Clang-Format VSCode extension 。demo用以下方法运行： 1$ ./scripts/watch-demo demos/nn-art/nn-art.ts （译者注：在deeplearn根目录下运行该命令）运行成功后命令行会出现如下内容： 12345&gt;&gt; Starting up http-server, serving ./&gt;&gt; Available on:&gt;&gt; http://127.0.0.1:8080&gt;&gt; Hit CTRL-C to stop the server&gt;&gt; 1357589 bytes written to dist/demos/nn-art/bundle.js (0.85 seconds) at 10:34:45 AM 然后，在浏览器中访问http://localhost:8080/demos/nn-art/nn-art-demo.html 。watch-demo 的脚本监视代码增量编译（~200-400ms），因此用户可以在开发应用程序的过程中有一个快速编辑刷新周期。在提交请求的时候，通过以下命令确保您的代码通过所有测试以及对程序进行了错误分析： 12$ npm run test$ npm run lint 构建一个独立的可以用script 标签导入到浏览器的ES5库： 1$ ./scripts/build-standalone.sh VERSION # 构建独立的库 1&gt;&gt; Stored standalone library at dist/deeplearn-VERSION(.min).js 构建一个仅运行和测试的npm包： 1$ ./scripts/build-npm.sh 1&gt;&gt; Stored npm package at dist/deeplearn-VERSION.tgz 在本地安装，运行: 1npm install ./dist/deeplearn-VERSION.tgz 在Windows上，用Git bash使用上面的脚本 4.支持环境WebGL1.0设备（具备OES_texture_float 扩展）和WebGL2.0设备。对于那些没有WebGL的平台，提供了CPU回退机制。然而，目前演示案例不支持手机、火狐以及Safari浏览器。请在PC端用谷歌浏览器进行浏览。"},{"title":"开源 JavaScript 机器学习框架","date":"2019-11-05T04:27:07.000Z","path":"2019/11/05/blog-009/","text":"大多数玩机器学习的同事在工作中都是用 Python 这样的语言完成的，但既然身处在 JavaScript 这个生态中，为什么不试试一起使用 JavaScript 玩 机器学习 呢？而且使用 JavaScript 还允许运行在浏览器和服务器端、甚至是桌面程序上。通过做一些Search和研究发现，这里的确有一些简洁的库，可以将 JavaScript、机器学习、DNN 甚至 NLP 结合在一起，而且在浏览器端大多库会调用 WebGL 来做机器学习的计算。下面是一些机器学习算法，基于这些算法可以使用本文中列出的不同JavaScript 框架来模型训练： 简单的线性回归 多变量线性回归 逻辑回归 朴素贝叶斯 k最近邻算法（KNN） K-means 支持向量机（SVM） 随机森林 决策树 前馈神经网络 深度学习网络 1.DeepLearn.jsDeeplearn.js是Google发布的一个开源的机器学习JavaScript 库，可用于不同的目的，例如在浏览器中训练神经网络，理解ML模型，用于教育目的等。你可以在推理模式中运行预先训练的模型。可以在Typescript（ES6 JavaScript ）或ES5 JavaScript 中编写代码。通过在HTML文件的head标签中包含以下代码并编写用于构建模型的JS程序，可以实现快速入门。 友链：Deeplearn入门 2.TensorFlow.jsTensorFlow.js 是一个开源的基于硬件加速的 JavaScript 的库，支持在浏览器或者 NodeJs 中来运行深度学习，并且能支持现有的 Tensorflow 模型，由Google出品。可以说是前端深度学习框架 Deeplearn.js 的继任者。它提供一系列简洁和通俗易懂的 API，用于训练、部署模型。而且因为可以运行在浏览器，所以可以直接通过 URL 就能分享你的程序 通过摄像头来控制的吃豆人游戏。 3.Brain.jsBrain.js 是同样可以运行在浏览器和 NodeJs 服务器端、能为不同的任务提供不同类型的训练网络。特点是让定义、训练以及执行神经网络变得特别简单。个人觉得这个库比较适合入门。比如以下短短几行代码已涵盖创建、训练和执行神经网络，一目了然： 4.Synaptic.jsSynaptic 可以运行在浏览器和 NodeJs 服务器端的神经网络库，你能够用它训练一层甚至是二层神经网络结构。该库包括一些内置的体系结构，如多层感知机MLP、长短时记忆网络、液体状态机和能够训练真实网络的训练器。 5.Machine learning (ml.js)Machine Learning tools 是由 mljs 组织开发的一组库，可以为 JavaScript 提供机器学习工具，类似于 Python 中的 scikit-learn，支持以下机器学习算法： 无监督学习 主成分分析（PCA） K均值聚类 监督学习 简单线性回归 多变量线性回归 支持向量机（SVM） 朴素贝叶斯 K最近邻算法（KNN） 偏最小二乘算法（PLS） 决策树：CART 随机森林 逻辑回归 人工神经网络 前馈神经网络 6.compromise基本上是NLP自然语言处理库 - 前端 JavaScript 实现的首选，这个库加上自己的资料库压缩成min.js后文件大小可达到300k以下，这样运行在浏览器和 NodeJs 服务器端都问题不大，具体可以做的东西是训练自定义语义库：划分出分词，获取句子的各个词性，可以把句子变积极消极、分词等，比如以下例子： 结语JavaScript 虽然不是机器学习的最佳编程语言，不过随着 Web生态 和人工智能技术近年来的不断发展完善，越来越多这样的机器学习工具库被研发和发布。对于一名Web的前端开发者而言，用 JavaScript 作为入门机器学习的桥梁是个不错的选择，它同样能帮助你开启机器学习之旅。"},{"title":"Npm vs Yarn","date":"2019-10-30T11:26:24.000Z","path":"2019/10/30/blog-008/","text":"前端工程化代码一般通过 包(package) (或者称为 模块（module）) 的方式来共享，因此你可以通过它使用全世界开发者的代码，或者分享自己的代码。开发者通常运用包管理工具来安装项目所需的依赖，因此出现许多包管理工具，比如：npm、yarn、bower等。 本文将带大家初步了解yarn 和npm。 什么是 Npm，Yarn1.npm 简介npm 即：npm package manager ，是一种重用其他开发人员的代码的方法，也是一种与他人共享代码的方式，并且可以很容易地管理不同版本的代码。npm 开始作为 Node 包管理器，所以你会发现很多模块可以在服务器端使用。也有很多的包添加命令供您在命令行中使用。你还会发现可以在前端使用的软件包。 npm 由三个不同的部分组成：网站，注册表和 CLI 。该网站是用户发现软件包的主要工具，注册表是一个关于软件包信息的大型数据库，而 CLI 则是开发者如何在注册表上发布他们的软件包或下载他们希望安装的软件包。更多详细内容，可参见 what-is-npm。 2.yarn 简介yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码，或者分享自己的代码。 yarn 做这些快捷、安全、可靠，所以你不用担心什么。通过 yarn，你可以使用其他开发者针对不同问题的解决方案，使自己的开发过程更简单。 使用过程中遇到问题，你可以将其上报或者贡献解决方案。一旦问题被修复，Yarn会更新保持同步。 yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。它并没有试图完全取代 npm。yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。它存在的目的是解决团队在使用 npm 面临的少数问题。当然，在 Node 版本断更替中，npm 本身也在积极更新 安装/更新1.npm 安装/更新 安装 npm 开始作为 Node 包管理器，所以它的安装是跟 Node.js 捆绑在一起的。至于如何安装 Node.js, Npm 官方，在 Installing Node.js and updating npm 做了阐述。之前在不同平台尝试更新 Node.js 之时，也是遇到过各种问题，有在 NodeJs 升级/安装折腾记 一文做了记载；折腾许久，得出的结论跟官网一致： 如果您使用的是OS X或Windows，安装Node.js的最佳方法是：使用 Node.js下载页面中的一个安装程序。 更新 npm install npm@latest -g （npm install npm -g） 更新(重新下载) Node.js 2.yarn 安装/更新 安装 对于如何安装 yarn，yarn 官方给出了很全面的说明，详见 Install Yarn；涵盖 MacOs，Windows，Linux 等平台，并且还给出一些备用安装方式，譬如通过 npm 来安装： 1npm install --global yarn 当然，yarn 官方在 Yarn 备选安装方式有明确讲道： 一般来说, 不推荐通过 npm 安装 yarn，在用基于 Node 的包管理器安装 yarn 时，该包未被签名， 并且只通过基本的 SHA1 散列进行唯一完整性检查。这在安装系统级应用时有安全风险。因为这些原因，高度推荐用你的操作系统最适合的方式来安装 yarn。 但在实际使用中，这倒是最为方便的方式之一，迄今倒也没遇到什么问题；当然，最好按照官方推荐的方式；如果你使用并熟悉 Mac 操作系统，用推荐方式安装 yarn 也是很简单：brew install yarn 更新 对于如何更新 yarn，可以结合安装时候对应命令；如果是 Mac 操作系统，使用 brew 安装，那么如此操作予以更新： 1brew upgrade yarn 如果 yarn 通过 Debian / Ubuntu 包安装，则可以运行如下命令予以更新： 1sudo apt-get update &amp;&amp; sudo apt-get install yarn 也可以使用 yarn 本身来更新自己： 1yarn global add yarn 如果有意了解更多如何更新 yarn 的方法，可参见：yarn self-update should update using the same installation method originally used npm 与 yarn 常用命令对比有所区别的命令 Npm Yarn 功能描述 npm install(npm i) yarn install(yarn) 根据 package.json 安装所有依赖 npm i –save [package] yarn add [package] 添加依赖包 npm i –save-dev [package] yarn add [package] –dev 添加依赖包至 devDependencies npm i -g [package] yarn global add [package] 进行全局安装依赖包 npm update –save yarn upgrade [package] 升级依赖包 npm uninstall [package] yarn remove [package] 移除依赖包 相同操作的命令 Npm Yarn 功能描述 npm run yarn run 运行 package.json 中预定义的脚本 npm config list yarn config list 查看配置信息 npm config set registry 仓库地址 yarn config set registry 仓库地址 更换仓库地址 npm init yarn init 互动式创建/更新 package.json 文件 npm list yarn list 查看当前目录下已安装的node包 npm login yarn login 保存你的用户名、邮箱 npm logout yarn logout 删除你的用户名、邮箱 npm outdated yarn outdated 检查过时的依赖包 npm link yarn link 开发时链接依赖包，以便在其他项目中使用 npm unlink yarn unlink 取消链接依赖包 npm publish yarn publish 将包发布到 npm npm test yarn test 测试 = yarn run test npm bin yarn bin 显示 bin 文件所在的安装目录 yarn info yarn info 显示一个包的信息 对于以上还须对于，还须做如下补充性说明： 在 npm 中，可以使用 npm config set save true 设置 —-save 为默认行为，但这对多数开发者而言，并非显而易见的。而使用 yarn，在package.json 中添加（add）和移除（remove）等行为是默认的。 对于要添加或升级的包，npm 与 yarn 都可以指定具体的版本，或者 Tag；如： yarn add [package]@[version]yarn add [package]@[tag] 在国内，使用 npm，最好还是替换成淘宝的镜像，如此网络影响减小到最低，这样安装依赖包的速度，可以得到蛮大的改善，可以参考文章 使用淘宝镜像解决npm速度慢的问题 npm 独有的命令 npm rebuild pacakgename: 用于更改包内容后进行重建；比如常见的 npm rebuild node-sass；当使用 Sass（Scss） 来作样式表预处理器，再打包的时候，你可能会遇见如下错误；而解决此问题，最为简单的方式即使用 rebuild 命令，对 node-sass 进行重建即可。 Module build failed: ModuleBuildError: Module build failed: Error: Node Sass does not yet support your current environment:This usually happens because your environment has changed since running npm install. Run npm rebuild node-sass to build the binding for your current environment. yarn 独有的命令 yarn import：依据原npm安装后的node_modules目录生成一份yarn.lock文件； yarn licenses：列出已安装包的许可证信息； yarn pack：创建一个压缩的包依赖 gzip 档案； yarn why：显示有关一个包为何被安装的信息。 yarn autoclean：从包依赖里清除并移除不需要的文件。 package-lock.json &amp; yarn.lock关于 yarn.lock有时候一个项目周期很长，在不断开发的同时，而依赖的库也会有很大改变；有时候你可能只想运行 npm i 更新没有下载的插件，却不想偶尔会将依赖的一些其他插件更到最新，导致各种奇葩问题；package-lock.json 和 yarn.lock 就是为解决这种问题而设定的存在。 使用 npm 或者 yarn，都会有 pacakge.json 这个文件，用以标出自己项目对 各库包的依赖。举个例子来说，你的项目中有如下依赖： 123&quot;dependencies&quot;: &#123; &quot;jade-package&quot;: &quot;^2.3.4&quot;&#125; 这其中的 ^ 是定义了向后(新)兼容依赖；在 npm&lt;5.0 以前，如果 jade-package 的版本超过2.3.4*，并在大版本号（2）上相同，就允许下载最新版本的 *jade-package 库包，例如实际上可能运行npm i时候，下载的具体版本可能是2.5.8。 多数情况下，这种向后兼容依赖下载最新库包，是没有问题的；然而，因为 npm 是开源世界，各库包的版本语义可能并不相同，不是所有开发者都能严格遵守这一原则：相同大版本号的同一个库包，其接口符合兼容要求。而且，不同的库包之间也存在其他依赖。理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略，有可能导致两台拥有相同 package.json 文件的机子，实际上安装了不同版本的包，这可能导致一些错误。有时候，相同机器稍不留神的一个 npm i，就可能导致 node_modules 中安装的实际依赖被更新，也就可能导致项目运行呈现，被面目全非。 yarn.lock 就是为解决此问题而衍生的存在；为了跨机器安装得到一致的结果，Yarn 需要比你配置在 package.json 中的依赖列表更多的信息。 Yarn 需要准确存储每个安装的依赖是哪个版本；它类似于 npm 的 npm-shrinkwrap.json，并且无副作用。只是需要注意的是： yarn.lock 文件是自动产生的，而且应该完全被 Yarn 管理。 当你用 Yarn CLI 增加／升级／删除依赖，它将自动更新你的 yarn.lock 文件。 不要直接编辑这个文件，那样很容易弄坏某些东西。 关于 package-lock.json当 Node.js 升级之 v8.0 以后，自带的 npm 也升级到了5.0；带来速度上很大提升之外，也带来了其他很大变大；这其中就包括 package-lock.json：安装模块操作（改变 node_modules 文件夹内容）会生成或更新 package-lock.json 文件；package-lock.json 之于 npm，即是yarn.lcok 之于 yarn 的翻版；更多信息可参见 npm package-lock.json。 另外，值得一提的是，在 Github 上有人专门提供了 Synp 工具，用以：将yarn.lock转换为package-lock.json，反之亦然（Convert yarn.lock to package-lock.json and vice versa）。 对比 npm，yarn 的优点 速度快 。速度快主要来自以下两个方面： 并行安装：无论 npm 还是 yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 yarn 是同步执行所有任务，提高了性能。 离线模式：如果之前已经安装过一个软件包，用yarn 再次安装时之间从缓存中获取，就不用像npm 那样再从网络下载了。 安装版本统一：为了防止拉取到不同的版本，yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。 更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，yarn 简洁太多：默认情况下，结合了 emoji 直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。 更好的语义化： yarn 改变了一些npm 命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。 小结 对比后发现，似乎yarn在各方面全面领先于npm。事实上，在npm5之前，yarn的优势特别明显。但是在npm5改进之后，二者差距不大， npm5值得尝试！ 个人建议：如果你已经在个人项目上使用 yarn ，并且没有遇到更多问题，目前完全可以继续使用。但如果有兼容 npm 的场景，或者身处在使用 npm ，cnpm 的团队，以及还没有切到 yarn 的项目，那现在就可以试一试 npm5 了。 更多文章：前端文章原文出处：Npm vs Yarn 之备忘详单"},{"title":"使用淘宝镜像解决npm速度慢的问题","date":"2019-10-30T04:35:13.000Z","path":"2019/10/30/blog-007/","text":"首先，淘宝镜像地址： http://npm.taobao.org/ 如何使用有很多方法来配置npm的registry地址，下面根据不同情景列出几种比较常用的方法。 淘宝镜像举例： 1.临时使用 npm –registry https://registry.npm.taobao.org install express 2.一直使用 npm config set registry https://registry.npm.taobao.org验证是否成功：npm config get registry 或 npm info express 3.使用cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org或cnpm install express"},{"title":"IE9(及以下)时间不兼容问题","date":"2019-10-30T04:33:51.000Z","path":"2019/10/30/blog-006/","text":"在Javascript中时间转化场景广泛，但针对低版本浏览器还是有兼容性问题的，下面做一个简单的总结。 一、 无参var dateTime = new Date(); 二、 有参构造函数 日期构造函数 1、对于日期格式类型为：yyyy-mm-dd 对于此种格式 IE9 以上全部支持，IE9 以下不支持 2、对于日期格式类型为：yyyy/mm/dd 对于此种格式 IE Google Firefox 全部支持 日期时间构造函数 1、对于日期时间格式类型为：yyyy-MM-dd hh:mm:ss 对于此种格式 IE 不兼容，new Date(yyyy-MM-dd hh:mm:ss) IE 报非法 date 类型 2、对于日期时间格式类型为: yyyy/MM/dd hh:mm:ss 对于此种格式 IE Google Firefox 都支持 3、对于日期时间格式类型为：yyyy-MM-ddThh:mm:ss 对于此种格式 IE9 只能获取到日期，时间可能是错误的 所以在JavaScript中，对于时间格式化最好使用 yyyy/MM/dd hh:mm:ss 123456789function format(value) &#123; if (value) &#123; value = val.replace(/-/g,&apos;/&apos;); var time = new Date(value); return time.dateFormat(&apos;Y-m-d hh:mm&apos;) &#125; else &#123; return &apos;&apos;; &#125; &#125;"},{"title":"webpack4 搭建项目框架","date":"2019-10-30T04:32:25.000Z","path":"2019/10/30/blog-005/","text":"本文主要跟大家分享一下如何使用webpack4来一步一步搭建自己的项目框架。如果没接触过webpack，建议在阅读本文之前先去webpack 中文网了解一下基本概念、核心理念 入口(entry)、输出(output)、loader、插件(plugins)等知识。 主要功能： 1、支持VUE 2、支持React 3、支持less、scss 4、图片压缩，css分离 5、px转rem 6、ES6 7、打包后自动压缩zip文件 8、支持本地调试 9、支持本地mock数据服务1、首先谈一谈使用webpack搭建项目框架的目的 随着公司发展，每个项目需要的人员也随之增加，但是大家的技术栈不一样，有vue，react，angular；有人习惯原生css，有人喜欢less、scss，在项目中，为了让大家都还使用自己擅长的技术栈来开发，带着这样的目的，从而从0到1，慢慢搭建起自己的项目框架，目前框架已生成脚手架，发布到npm，有兴趣的同学可以安装体验一下。 使用步骤： 1、安装脚手架，执行 npm install light-app-cli -g 2、创建项目，执行light-app-cli &lt;项目名称&gt; 3、详见 [GitHub地址](https://github.com/hanhan3682523/light-app-cli)2、webpack搭建项目框架的过程1、生成环境及主流程环境要求： 1、node &gt;= 10.5.0,[node下载地址]: https://nodejs.org/en/download/ 2、webpack &gt;=4.16.0,安装：npm install -g webpack 3、框架目录结构预览 搭建流程： 1、目录及文件说明 2、配置入口(entry) 3、配置出口(output) 4、配置loader 5、配置插件(plugins) 6、开发环境配置devSever2、目录及文件说明|- build -- webpack.base.conf.js--开发和打包用到的公用配置项，通过webpack-merge 分别使用 -- webpack.build.config.js--打包配置 -- webpack.dev.config.js--开发配置，生成本地服务，设置访问域名、热替换、代理、端口等信息 -- webpack.plugins.js--配置webpack插件 -- webpack.rules.js--配置webpack loader，进行文件处理 |- config -- index.js--本地服务域名、端口等配置 |- dist |- mock -- data.js--设置mock接口数据 -- server.js--本地mock服务 |- src |- assets |- css |- image |- js -- index.html |- zip |- .babelc |- package.json |- postcss.config.js |- tsconfig.json2、配置入口(entry) 项目为多页面应用，会涉及到多个入口，所以我们进行约定，所有入口文件统一放到src目录下的js文件夹中，利用globby模块，读取js文件夹下的所有js名称(不包括子文件夹)，从而返回一个入口(entry)对象。 123456789101112131415161718//读取文件const glob = require(&apos;globby&apos;);let entryConfig = (function() &#123; let _config = &#123;&#125;; //选择js目录下的文件，不包含common中的js作为入口 const fileList = glob.sync([&apos;./src/js/*.*&apos;]); console.info(&apos;tag&apos;, fileList); if (fileList &amp;&amp; fileList.length &gt; 0) &#123; for (let i = 0; i &lt; fileList.length; i++) &#123; _config[fileList[i].match(/([^\\/]+)(?=\\.)/ig)[0]] = fileList[i]; &#125; &#125; return _config;&#125;)();//入口entry: entryConfig, 3、配置出口(output) 在filename中添加了hash命名，目的是为了防止cdn缓存、浏览器缓存，每次打包，都会对静态资源重新命名，这样修改发布后，只需要推html的缓存即可。 12345678//出口output: &#123; filename: &apos;js/[name][hash].js&apos;, path: config.build.assetsRoot, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath&#125;, 4、配置loader 项目中文件类型较多，每种文件类型都有专门的loader进行处理，涉及的loader比较多，所以把loader统一放到webpack.rules.js中进行管理，方便维护和扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//loader，rulesConfig内容详见下面webpack.rules.jsmodule: &#123; rules: rulesConfig&#125;,//webpack.rules.js 中内容const path = require(&apos;path&apos;);const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);function resolve(dir) &#123; return path.join(__dirname, &apos;..&apos;, dir)&#125;module.exports = [&#123; test: /\\.vue$/, use: &#123; loader: &apos;vue-loader&apos; &#125;, //加快搜索速度 exclude: resolve(&apos;node_modules&apos;),&#125;, &#123; test: /\\.ts$/, use: &#123; loader: &apos;ts-loader&apos; &#125;, //加快搜索速度 exclude: resolve(&apos;node_modules&apos;),&#125;, &#123; test: /\\.js$/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;env&apos;, &apos;react&apos;], plugins: [&apos;transform-runtime&apos;], cacheDirectory: true &#125; &#125;, exclude: resolve(&apos;node_modules&apos;),&#125;, &#123; test: /\\.css$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;postcss-loader&quot;], // css中的基础路径 publicPath: &quot;../&quot; &#125;)&#125;, &#123; test: /\\.((woff2?|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9]))|(woff2?|svg|jpe?g|png|gif|ico)$/, use: [&#123; loader: &apos;url-loader&apos;, options: &#123; limit: 8192, //设置转换成base64的大小 name: &apos;[name][hash:8].[ext]&apos;, outputPath: &apos;image/&apos; &#125; &#125;], //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;, &#123; test: /\\.(html)$/, use: &#123; loader: &apos;html-loader&apos; &#125;, //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;, &#123; test: /\\.less$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;postcss-loader&quot;, &quot;less-loader&quot;], // css中的基础路径 publicPath: &quot;../&quot; &#125;), //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;, &#123; test: /\\.(scss|sass)$/, // 分离的写法 use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;postcss-loader&quot;, &quot;sass-loader&quot;], // css中的基础路径 publicPath: &quot;../&quot; &#125;), //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;]; 5、配置插件(plugins) 插件可以自定义webpack的构建过程，webpack本身也内置了一些插件。同loader一样，为了便于管理，我们把插件统一放到webpack.plugins.js中进行管理,这里面使用插件主要用于分离css文件，处理vue文件，以及打包后自动压缩zip文件等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//插件，pluginsConfig内容见下面webpack.plugins.jsplugins: pluginsConfig//webpack.plugins.js//配置文件const config = require(&apos;../config/index&apos;)//路徑const path = require(&apos;path&apos;);// html模板const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);// 清除目录等const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);// 分离cssconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);//静态资源输出const copyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);//css压缩const OptimizeCssAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);//vue插件const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);//打包文件const FileManagerPlugin = require(&apos;filemanager-webpack-plugin&apos;);//读取文件var glob = require(&apos;globby&apos;);//webpackconst webpack = require(&apos;webpack&apos;);var pluginsConfig = [ new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // 调用之前先清除 new CleanWebpackPlugin([&apos;dist&apos;, &apos;zip&apos;], &#123; root: path.resolve(__dirname, &quot;..&quot;) &#125;), //vue插件 new VueLoaderPlugin(), //静态资源输出 new copyWebpackPlugin([&#123; from: path.resolve(__dirname, &quot;../src/assets&quot;), to: &apos;./assets&apos; &#125;]), // 分离css插件参数为提取出去的路径 new extractTextPlugin(&#123; filename: &apos;style/[name][hash].css&apos;, &#125;), //css进行压缩 new OptimizeCssAssetsPlugin(&#123; //assetNameRegExp: /\\.style\\.css$/g, cssProcessor: require(&apos;cssnano&apos;), cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;, canPrint: true &#125;)];(function() &#123; const fileList = glob.sync([&apos;./src/*.html&apos;]); if (fileList &amp;&amp; fileList.length &gt; 0) &#123; for (var i = 0; i &lt; fileList.length; i++) &#123; pluginsConfig.push( new HtmlWebpackPlugin(&#123; template: fileList[i], filename: fileList[i].match(/([^\\/]+)(?=\\.)/ig)[0] + &apos;.html&apos;, chunks: [fileList[i].match(/([^\\/]+)(?=\\.)/ig)[0]], hash: false, //引入的文件设置hash值 &#125;) ); &#125; &#125;&#125;)();//自动压缩dist 到zip文件//环境判断if (process.env &amp;&amp; process.env.NODE_ENV &amp;&amp; process.env.NODE_ENV.trim() === &quot;production&quot; &amp;&amp; config.build.zipName) &#123; // 调用之前先清除 pluginsConfig.push(new CleanWebpackPlugin([&apos;zip&apos;])); let _zipfilename = config.build.zipName; pluginsConfig.push(new FileManagerPlugin(&#123; onEnd: &#123; //c mkdir: [&apos;./zip&apos;, &apos;./tempzip/&apos; + _zipfilename], copy: [&#123; source: &apos;./dist&apos;, destination: &apos;./tempzip/&apos; + _zipfilename &#125;, ], archive: [&#123; source: &apos;./tempzip/&apos;, destination: &apos;./zip/&apos; + _zipfilename + &apos;.zip&apos; &#125;], delete: [ &apos;./tempzip/&apos; ] &#125; &#125;));&#125;module.exports = pluginsConfig; 6、开发环境配置devSever 项目开发过程中，为了便于开发调试，我们需要设置本地开发环境，起http服务，支持自动打开浏览器，文件修改后自动刷新或热更新页面，https，接口请求代理等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const config = require(&apos;../config/index&apos;)const common = require(&apos;./webpack.base.conf&apos;);const merge = require(&apos;webpack-merge&apos;);module.exports = merge(common, &#123; mode: &apos;development&apos;, //生成map文件，供调试 devtool: &apos;eval-source-map&apos;, //监听文件更新，在文件发生变化时重新编译,使用 DevServer 时，监听模式默认是开启的。 watch: true, //控制监听模式 watchOptions: &#123; // 不监听的文件或文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高，默认为 300ms aggregateTimeout: 300, // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的,默认每秒轮询1000次 poll: 1000 &#125;, //http服务设置 devServer: &#123; //代理 proxy: &#123; &apos;/api&apos;: &apos;http://127.0.0.1:9001&apos;, changeOrigin: true &#125;, //运行目录 contentBase: &apos;./&apos;, //一切服务都启用gzip 压缩： compress: true, //端口号 port: config.dev.port || &apos;8080&apos;, //自动打开浏览器 open: true, //模块热替换 hot: true, //页面自动刷新 inline: true, //打开的页面 openPage: &apos;&apos;, //host:&apos;0.0.0.0&apos;--别人可以访问 host: config.dev.host || &apos;hxj.com&apos;, //支持https https: config.dev.https, &#125;&#125;);"},{"title":"JavaScript判断对象是否相等","date":"2019-10-30T04:31:05.000Z","path":"2019/10/30/blog-004/","text":"在Javascript中相等运算包括”==”,”===”，两者不同之处，不必细说。本文主要跟大家探讨如何判断两个对象是否相等。有人可能认为两个对象有相同的属性以及对应的属相有相同的值，那么这两个对象就相等。事实是这样吗？我们验证一下： 1234567891011121314var obj0 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj1 = &#123; name: &quot;zhangsan&quot;, age: 18&#125; //Outputs: falseconsole.log(obj0 == obj1); //Outputs: falseconsole.log(obj0 === obj1); 通过例子我们很明显发现，无论是“==”还是“===”都返回false。原因是：基本类型string,number通过值来比较，而对象（Date,Array,Function）及普通对象通过指针指向的内存中的地址来做比较。以上例子我们做个修改就能看出端倪： 123456789101112131415161718192021var obj0 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj1 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj2 = obj0;//Outputs: trueconsole.log(obj0 == obj2);//Outputs: trueconsole.log(obj0 === obj2);//Outputs: falseconsole.log(obj1 == obj2); //Outputs: falseconsole.log(obj1 === obj2); 修改之后返回true。原因是obj0和ob3的指针指向了内存中的同一个地址；这和面向对象的语言（Java/C）中值传递和引用传递的概念相似。如果你想判断两个对象是否相等，首先要明确你是想判断两个对象的属性是否相同，还是属性对应的值是否相同，还是其他。如果你判断两个对象的值是否相等，可以这样： 1234567891011121314151617181920212223242526272829function isObjectValueEqual(a, b) &#123; // 获取对象的属性集合（数组） var aProps = Object.getOwnPropertyNames(a); var bProps = Object.getOwnPropertyNames(b); // 属性个数（长度）不同，对象肯定不同 if (aProps.length != bProps.length) &#123; return false; &#125; for (var i = 0; i &lt; aProps.length; i++) &#123; var propName = aProps[i]; if (a[propName] !== b[propName]) &#123; return false; &#125; &#125; return true;&#125;var obj0 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj1 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;//Outputs: trueconsole.log(isObjectValueEqual(obj0, obj1)); 检查对象的“值相等”我们基本上是要遍历的对象的每个属性，看看它们是否相等。虽然这个简单的实现适用于我们的例子中，但是却不能通用。我们知道JavaScript中的对象不仅仅是例子中的那种简单对象，还有（Array,Date,Function）等等。这样一来我们的方法就会出现判断不出的情况： 1、对象某个属性值为其他对象（Array,Date,String,Function）等 2、对象某个属性值为underfined，另一个对象没有这个属性值 3、对象某个属性值为NaN（未深入研究） 最后经过度娘找到一个检查对象的“值相等”的一个强大的方法，它依靠完善的测试库，涵盖了各种边界情况。Underscore和Lo-Dash有一个名为_.isEqual()方法，用来比较好的处理深度对象的比较。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Outputs: trueconsole.log(_.isEqual(obj0, obj1));// Underscore中isEqual的部分源码var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren&apos;t identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. case &apos;[object RegExp]&apos;: // RegExps are coerced to strings for comparison (Note: &apos;&apos; + /a/i === &apos;/a/i&apos;) case &apos;[object String]&apos;: // Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is // equivalent to `new String(&quot;5&quot;)`. return &apos;&apos; + a === &apos;&apos; + b; case &apos;[object Number]&apos;: // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; case &apos;[object Date]&apos;: case &apos;[object Boolean]&apos;: // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; &#125; if (typeof a != &apos;object&apos; || typeof b != &apos;object&apos;) return false; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Objects with different constructors are not equivalent, but `Object`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if ( aCtor !== bCtor &amp;&amp; // Handle Object.create(x) cases &apos;constructor&apos; in a &amp;&amp; &apos;constructor&apos; in b &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) ) &#123; return false; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); var size, result; // Recursively compare objects and arrays. if (className === &apos;[object Array]&apos;) &#123; // Compare array lengths to determine if a deep comparison is necessary. size = a.length; result = size === b.length; if (result) &#123; // Deep compare the contents, ignoring non-numeric properties. while (size--) &#123; if (!(result = eq(a[size], b[size], aStack, bStack))) break; &#125; &#125; &#125; else &#123; // Deep compare objects. var keys = _.keys(a), key; size = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. result = _.keys(b).length === size; if (result) &#123; while (size--) &#123; // Deep compare each member key = keys[size]; if (!(result = _.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) break; &#125; &#125; &#125; // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return result;&#125;; // Perform a deep comparison to check if two objects are equal._.isEqual = function(a, b) &#123; return eq(a, b, [], []);&#125;;"},{"title":"将一个JS数组乱序输出","date":"2019-10-30T04:23:45.000Z","path":"2019/10/30/blog-003/","text":"在Javascript可能有这样的需求：将一个数组乱序输出，推荐两种方法。 1、splice()方法 123456789function shuffle(a) &#123; var arr = []; while (a.length &gt; 0) &#123; var i= parseInt(Math.random() * (a.length - 1)); arr.push(a[i]); a.splice(i, 1); &#125; return arr;&#125; 2、洗牌法 效率高 12345678910function shuffle(a) &#123; var len = a.length; for (var i = 0; i &lt; len - 1; i++) &#123; var index = parseInt(Math.random() * (len - i)); var temp = a[index]; a[index] = a[len - i - 1]; a[len - i - 1] = temp; &#125; return a;&#125;"},{"title":"JS中call、apply、bind三者的作用和区别","date":"2019-10-30T03:05:46.000Z","path":"2019/10/30/blog-002/","text":"在刚接触javascript时，就碰到call(),apply(),bind()，我一直不是很明白。在工作中接触它们次数多了，对这三个方法也有了点理解，总的就是一句话：三者的作用都是改变函数的执行上下文。今天把它们简单阐述一下！ JavaScript权威指南上的解释是： call() 、apply()可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。我理解它们的作用是：都能继承另一个对象的方法和属性。bind() 就是将某个函数(属性或方法)绑定到某个对象上。 12345var obj = &#123;name: &quot;Tom&quot;&#125;function foo() &#123;console.log(this.name)&#125;foo.call(obj) //打印结果： Tom this 指向 指定的对象（obj） 1.call() 和 apply() 的第一个参数都是指定的对象。这个对象就是该函数的执行上下文2.call() 和 apply() 的区别：两者之间的参数不同 - call() 在第一个参数之后的 后续所有参数就是传入该函数的值（形参）。 - apply() 只有两个参数，第一个是指定的对象，第二个是数组，这个数组的每一个元素都是该函数的参数（形参）。 12345678910// call()函数var obj = &#123; message: &apos;My name is: &apos;&#125;function getName(firstName, lastName) &#123; console.log(this.message + firstName);&#125;getName.call(obj, &apos;Tom&apos;, &apos;Jorry&apos;) // My name is: Tom this 指向 指定的对象（obj） 123456789101112// apply() 函数var obj = &#123; message: &apos;My name is: &apos;&#125;function getName(firstName, lastName) &#123; console.log(this.message + firstName);&#125;getName.apply(obj, [&apos;Tom&apos;, &apos;Jorry&apos;]) // My name is: Tom 传参 是一个数组// this 指向 指定的对象（obj） bind() 它的参数和call()相同。它和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。"},{"title":"几款免费开放的接口API","date":"2019-10-29T10:04:38.000Z","path":"2019/10/29/blog-001/","text":"前端开发者经常面对五花八门的技术，通常为了更好的适应潮流需要学习和实战。但是实战演练过程中往往因为没有后端开发配合，演练总会有不足之处…那就是接口，接口，接口！下面为大家推荐几个开放的API接口地址 小白接口小白接口特点： 接口全面，速度快 能自己建模，调用属于自己的接口 官方人员在线给予技术支持，响应速度超快 免费 免费 免费！ 非常适合前端开发学习使用！强烈推荐！强烈推荐！强烈推荐！ 小白地址 http://open.yesapi.cn/?r=user/registration&amp;from=January 技术QQ群： 660311764 API工厂API工厂特点就是接口全面，速度也不错唯一缺点就是：有些功能必须花钱总体来说值得推荐 接口文档地址：https://api.it120.cc/doc.html 后台管理地址：https://admin.it120.cc/ 其他还有一些开发接口，不过因为各种原因用起来比较麻烦 apiopen ：https://www.apiopen.top 豆瓣API 貌似挂啦 看着篇就够了：https://blog.csdn.net/qq_31754523/article/details/94665791 Mock.js会用mockjs搞数据的就用mock吧，各有利弊，看个人习惯 Mock.js: http://mockjs.com/"}]