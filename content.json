[{"title":"Npm vs Yarn","date":"2019-10-30T11:26:24.000Z","path":"2019/10/30/blog-008/","text":""},{"title":"使用淘宝镜像解决npm速度慢的问题","date":"2019-10-30T04:35:13.000Z","path":"2019/10/30/blog-007/","text":"首先，淘宝镜像地址： http://npm.taobao.org/ 如何使用有很多方法来配置npm的registry地址，下面根据不同情景列出几种比较常用的方法。 淘宝镜像举例： 1.临时使用 npm –registry https://registry.npm.taobao.org install express 2.一直使用 npm config set registry https://registry.npm.taobao.org验证是否成功：npm config get registry 或 npm info express 3.使用cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org或cnpm install express"},{"title":"IE9(及以下)时间不兼容问题","date":"2019-10-30T04:33:51.000Z","path":"2019/10/30/blog-006/","text":"在Javascript中时间转化场景广泛，但针对低版本浏览器还是有兼容性问题的，下面做一个简单的总结。 一、 无参var dateTime = new Date(); 二、 有参构造函数 日期构造函数 1、对于日期格式类型为：yyyy-mm-dd 对于此种格式 IE9 以上全部支持，IE9 以下不支持 2、对于日期格式类型为：yyyy/mm/dd 对于此种格式 IE Google Firefox 全部支持 日期时间构造函数 1、对于日期时间格式类型为：yyyy-MM-dd hh:mm:ss 对于此种格式 IE 不兼容，new Date(yyyy-MM-dd hh:mm:ss) IE 报非法 date 类型 2、对于日期时间格式类型为: yyyy/MM/dd hh:mm:ss 对于此种格式 IE Google Firefox 都支持 3、对于日期时间格式类型为：yyyy-MM-ddThh:mm:ss 对于此种格式 IE9 只能获取到日期，时间可能是错误的 所以在JavaScript中，对于时间格式化最好使用 yyyy/MM/dd hh:mm:ss 123456789function format(value) &#123; if (value) &#123; value = val.replace(/-/g,&apos;/&apos;); var time = new Date(value); return time.dateFormat(&apos;Y-m-d hh:mm&apos;) &#125; else &#123; return &apos;&apos;; &#125; &#125;"},{"title":"webpack4 搭建项目框架","date":"2019-10-30T04:32:25.000Z","path":"2019/10/30/blog-005/","text":"本文主要跟大家分享一下如何使用webpack4来一步一步搭建自己的项目框架。如果没接触过webpack，建议在阅读本文之前先去webpack 中文网了解一下基本概念、核心理念 入口(entry)、输出(output)、loader、插件(plugins)等知识。 主要功能： 1、支持VUE 2、支持React 3、支持less、scss 4、图片压缩，css分离 5、px转rem 6、ES6 7、打包后自动压缩zip文件 8、支持本地调试 9、支持本地mock数据服务1、首先谈一谈使用webpack搭建项目框架的目的 随着公司发展，每个项目需要的人员也随之增加，但是大家的技术栈不一样，有vue，react，angular；有人习惯原生css，有人喜欢less、scss，在项目中，为了让大家都还使用自己擅长的技术栈来开发，带着这样的目的，从而从0到1，慢慢搭建起自己的项目框架，目前框架已生成脚手架，发布到npm，有兴趣的同学可以安装体验一下。 使用步骤： 1、安装脚手架，执行 npm install light-app-cli -g 2、创建项目，执行light-app-cli &lt;项目名称&gt; 3、详见 [GitHub地址](https://github.com/hanhan3682523/light-app-cli)2、webpack搭建项目框架的过程1、生成环境及主流程环境要求： 1、node &gt;= 10.5.0,[node下载地址]: https://nodejs.org/en/download/ 2、webpack &gt;=4.16.0,安装：npm install -g webpack 3、框架目录结构预览 搭建流程： 1、目录及文件说明 2、配置入口(entry) 3、配置出口(output) 4、配置loader 5、配置插件(plugins) 6、开发环境配置devSever2、目录及文件说明|- build -- webpack.base.conf.js--开发和打包用到的公用配置项，通过webpack-merge 分别使用 -- webpack.build.config.js--打包配置 -- webpack.dev.config.js--开发配置，生成本地服务，设置访问域名、热替换、代理、端口等信息 -- webpack.plugins.js--配置webpack插件 -- webpack.rules.js--配置webpack loader，进行文件处理 |- config -- index.js--本地服务域名、端口等配置 |- dist |- mock -- data.js--设置mock接口数据 -- server.js--本地mock服务 |- src |- assets |- css |- image |- js -- index.html |- zip |- .babelc |- package.json |- postcss.config.js |- tsconfig.json2、配置入口(entry) 项目为多页面应用，会涉及到多个入口，所以我们进行约定，所有入口文件统一放到src目录下的js文件夹中，利用globby模块，读取js文件夹下的所有js名称(不包括子文件夹)，从而返回一个入口(entry)对象。 123456789101112131415161718//读取文件const glob = require(&apos;globby&apos;);let entryConfig = (function() &#123; let _config = &#123;&#125;; //选择js目录下的文件，不包含common中的js作为入口 const fileList = glob.sync([&apos;./src/js/*.*&apos;]); console.info(&apos;tag&apos;, fileList); if (fileList &amp;&amp; fileList.length &gt; 0) &#123; for (let i = 0; i &lt; fileList.length; i++) &#123; _config[fileList[i].match(/([^\\/]+)(?=\\.)/ig)[0]] = fileList[i]; &#125; &#125; return _config;&#125;)();//入口entry: entryConfig, 3、配置出口(output) 在filename中添加了hash命名，目的是为了防止cdn缓存、浏览器缓存，每次打包，都会对静态资源重新命名，这样修改发布后，只需要推html的缓存即可。 12345678//出口output: &#123; filename: &apos;js/[name][hash].js&apos;, path: config.build.assetsRoot, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath&#125;, 4、配置loader 项目中文件类型较多，每种文件类型都有专门的loader进行处理，涉及的loader比较多，所以把loader统一放到webpack.rules.js中进行管理，方便维护和扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//loader，rulesConfig内容详见下面webpack.rules.jsmodule: &#123; rules: rulesConfig&#125;,//webpack.rules.js 中内容const path = require(&apos;path&apos;);const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);function resolve(dir) &#123; return path.join(__dirname, &apos;..&apos;, dir)&#125;module.exports = [&#123; test: /\\.vue$/, use: &#123; loader: &apos;vue-loader&apos; &#125;, //加快搜索速度 exclude: resolve(&apos;node_modules&apos;),&#125;, &#123; test: /\\.ts$/, use: &#123; loader: &apos;ts-loader&apos; &#125;, //加快搜索速度 exclude: resolve(&apos;node_modules&apos;),&#125;, &#123; test: /\\.js$/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;env&apos;, &apos;react&apos;], plugins: [&apos;transform-runtime&apos;], cacheDirectory: true &#125; &#125;, exclude: resolve(&apos;node_modules&apos;),&#125;, &#123; test: /\\.css$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;postcss-loader&quot;], // css中的基础路径 publicPath: &quot;../&quot; &#125;)&#125;, &#123; test: /\\.((woff2?|svg)(\\?v=[0-9]\\.[0-9]\\.[0-9]))|(woff2?|svg|jpe?g|png|gif|ico)$/, use: [&#123; loader: &apos;url-loader&apos;, options: &#123; limit: 8192, //设置转换成base64的大小 name: &apos;[name][hash:8].[ext]&apos;, outputPath: &apos;image/&apos; &#125; &#125;], //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;, &#123; test: /\\.(html)$/, use: &#123; loader: &apos;html-loader&apos; &#125;, //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;, &#123; test: /\\.less$/, use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;postcss-loader&quot;, &quot;less-loader&quot;], // css中的基础路径 publicPath: &quot;../&quot; &#125;), //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;, &#123; test: /\\.(scss|sass)$/, // 分离的写法 use: extractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&quot;css-loader&quot;, &quot;postcss-loader&quot;, &quot;sass-loader&quot;], // css中的基础路径 publicPath: &quot;../&quot; &#125;), //只命中src目录中的文件，加快搜索速度 include: resolve(&apos;src&apos;)&#125;]; 5、配置插件(plugins) 插件可以自定义webpack的构建过程，webpack本身也内置了一些插件。同loader一样，为了便于管理，我们把插件统一放到webpack.plugins.js中进行管理,这里面使用插件主要用于分离css文件，处理vue文件，以及打包后自动压缩zip文件等。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//插件，pluginsConfig内容见下面webpack.plugins.jsplugins: pluginsConfig//webpack.plugins.js//配置文件const config = require(&apos;../config/index&apos;)//路徑const path = require(&apos;path&apos;);// html模板const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);// 清除目录等const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);// 分离cssconst extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);//静态资源输出const copyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);//css压缩const OptimizeCssAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);//vue插件const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);//打包文件const FileManagerPlugin = require(&apos;filemanager-webpack-plugin&apos;);//读取文件var glob = require(&apos;globby&apos;);//webpackconst webpack = require(&apos;webpack&apos;);var pluginsConfig = [ new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin(), // 调用之前先清除 new CleanWebpackPlugin([&apos;dist&apos;, &apos;zip&apos;], &#123; root: path.resolve(__dirname, &quot;..&quot;) &#125;), //vue插件 new VueLoaderPlugin(), //静态资源输出 new copyWebpackPlugin([&#123; from: path.resolve(__dirname, &quot;../src/assets&quot;), to: &apos;./assets&apos; &#125;]), // 分离css插件参数为提取出去的路径 new extractTextPlugin(&#123; filename: &apos;style/[name][hash].css&apos;, &#125;), //css进行压缩 new OptimizeCssAssetsPlugin(&#123; //assetNameRegExp: /\\.style\\.css$/g, cssProcessor: require(&apos;cssnano&apos;), cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125;, canPrint: true &#125;)];(function() &#123; const fileList = glob.sync([&apos;./src/*.html&apos;]); if (fileList &amp;&amp; fileList.length &gt; 0) &#123; for (var i = 0; i &lt; fileList.length; i++) &#123; pluginsConfig.push( new HtmlWebpackPlugin(&#123; template: fileList[i], filename: fileList[i].match(/([^\\/]+)(?=\\.)/ig)[0] + &apos;.html&apos;, chunks: [fileList[i].match(/([^\\/]+)(?=\\.)/ig)[0]], hash: false, //引入的文件设置hash值 &#125;) ); &#125; &#125;&#125;)();//自动压缩dist 到zip文件//环境判断if (process.env &amp;&amp; process.env.NODE_ENV &amp;&amp; process.env.NODE_ENV.trim() === &quot;production&quot; &amp;&amp; config.build.zipName) &#123; // 调用之前先清除 pluginsConfig.push(new CleanWebpackPlugin([&apos;zip&apos;])); let _zipfilename = config.build.zipName; pluginsConfig.push(new FileManagerPlugin(&#123; onEnd: &#123; //c mkdir: [&apos;./zip&apos;, &apos;./tempzip/&apos; + _zipfilename], copy: [&#123; source: &apos;./dist&apos;, destination: &apos;./tempzip/&apos; + _zipfilename &#125;, ], archive: [&#123; source: &apos;./tempzip/&apos;, destination: &apos;./zip/&apos; + _zipfilename + &apos;.zip&apos; &#125;], delete: [ &apos;./tempzip/&apos; ] &#125; &#125;));&#125;module.exports = pluginsConfig; 6、开发环境配置devSever 项目开发过程中，为了便于开发调试，我们需要设置本地开发环境，起http服务，支持自动打开浏览器，文件修改后自动刷新或热更新页面，https，接口请求代理等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const config = require(&apos;../config/index&apos;)const common = require(&apos;./webpack.base.conf&apos;);const merge = require(&apos;webpack-merge&apos;);module.exports = merge(common, &#123; mode: &apos;development&apos;, //生成map文件，供调试 devtool: &apos;eval-source-map&apos;, //监听文件更新，在文件发生变化时重新编译,使用 DevServer 时，监听模式默认是开启的。 watch: true, //控制监听模式 watchOptions: &#123; // 不监听的文件或文件夹，支持正则匹配 ignored: /node_modules/, // 监听到变化发生后会等300ms再去执行动作，防止文件更新太快导致重新编译频率太高，默认为 300ms aggregateTimeout: 300, // 判断文件是否发生变化是通过不停的去询问系统指定文件有没有变化实现的,默认每秒轮询1000次 poll: 1000 &#125;, //http服务设置 devServer: &#123; //代理 proxy: &#123; &apos;/api&apos;: &apos;http://127.0.0.1:9001&apos;, changeOrigin: true &#125;, //运行目录 contentBase: &apos;./&apos;, //一切服务都启用gzip 压缩： compress: true, //端口号 port: config.dev.port || &apos;8080&apos;, //自动打开浏览器 open: true, //模块热替换 hot: true, //页面自动刷新 inline: true, //打开的页面 openPage: &apos;&apos;, //host:&apos;0.0.0.0&apos;--别人可以访问 host: config.dev.host || &apos;hxj.com&apos;, //支持https https: config.dev.https, &#125;&#125;);"},{"title":"JavaScript判断对象是否相等","date":"2019-10-30T04:31:05.000Z","path":"2019/10/30/blog-004/","text":"在Javascript中相等运算包括”==”,”===”，两者不同之处，不必细说。本文主要跟大家探讨如何判断两个对象是否相等。有人可能认为两个对象有相同的属性以及对应的属相有相同的值，那么这两个对象就相等。事实是这样吗？我们验证一下： 1234567891011121314var obj0 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj1 = &#123; name: &quot;zhangsan&quot;, age: 18&#125; //Outputs: falseconsole.log(obj0 == obj1); //Outputs: falseconsole.log(obj0 === obj1); 通过例子我们很明显发现，无论是“==”还是“===”都返回false。原因是：基本类型string,number通过值来比较，而对象（Date,Array,Function）及普通对象通过指针指向的内存中的地址来做比较。以上例子我们做个修改就能看出端倪： 123456789101112131415161718192021var obj0 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj1 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj2 = obj0;//Outputs: trueconsole.log(obj0 == obj2);//Outputs: trueconsole.log(obj0 === obj2);//Outputs: falseconsole.log(obj1 == obj2); //Outputs: falseconsole.log(obj1 === obj2); 修改之后返回true。原因是obj0和ob3的指针指向了内存中的同一个地址；这和面向对象的语言（Java/C）中值传递和引用传递的概念相似。如果你想判断两个对象是否相等，首先要明确你是想判断两个对象的属性是否相同，还是属性对应的值是否相同，还是其他。如果你判断两个对象的值是否相等，可以这样： 1234567891011121314151617181920212223242526272829function isObjectValueEqual(a, b) &#123; // 获取对象的属性集合（数组） var aProps = Object.getOwnPropertyNames(a); var bProps = Object.getOwnPropertyNames(b); // 属性个数（长度）不同，对象肯定不同 if (aProps.length != bProps.length) &#123; return false; &#125; for (var i = 0; i &lt; aProps.length; i++) &#123; var propName = aProps[i]; if (a[propName] !== b[propName]) &#123; return false; &#125; &#125; return true;&#125;var obj0 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;var obj1 = &#123; name: &quot;zhangsan&quot;, age: 18&#125;//Outputs: trueconsole.log(isObjectValueEqual(obj0, obj1)); 检查对象的“值相等”我们基本上是要遍历的对象的每个属性，看看它们是否相等。虽然这个简单的实现适用于我们的例子中，但是却不能通用。我们知道JavaScript中的对象不仅仅是例子中的那种简单对象，还有（Array,Date,Function）等等。这样一来我们的方法就会出现判断不出的情况： 1、对象某个属性值为其他对象（Array,Date,String,Function）等 2、对象某个属性值为underfined，另一个对象没有这个属性值 3、对象某个属性值为NaN（未深入研究） 最后经过度娘找到一个检查对象的“值相等”的一个强大的方法，它依靠完善的测试库，涵盖了各种边界情况。Underscore和Lo-Dash有一个名为_.isEqual()方法，用来比较好的处理深度对象的比较。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Outputs: trueconsole.log(_.isEqual(obj0, obj1));// Underscore中isEqual的部分源码var eq = function(a, b, aStack, bStack) &#123; // Identical objects are equal. `0 === -0`, but they aren&apos;t identical. // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal). if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`. if (a == null || b == null) return a === b; // Unwrap any wrapped objects. if (a instanceof _) a = a._wrapped; if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names. var className = toString.call(a); if (className !== toString.call(b)) return false; switch (className) &#123; // Strings, numbers, regular expressions, dates, and booleans are compared by value. case &apos;[object RegExp]&apos;: // RegExps are coerced to strings for comparison (Note: &apos;&apos; + /a/i === &apos;/a/i&apos;) case &apos;[object String]&apos;: // Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is // equivalent to `new String(&quot;5&quot;)`. return &apos;&apos; + a === &apos;&apos; + b; case &apos;[object Number]&apos;: // `NaN`s are equivalent, but non-reflexive. // Object(NaN) is equivalent to NaN if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values. return +a === 0 ? 1 / +a === 1 / b : +a === +b; case &apos;[object Date]&apos;: case &apos;[object Boolean]&apos;: // Coerce dates and booleans to numeric primitive values. Dates are compared by their // millisecond representations. Note that invalid dates with millisecond representations // of `NaN` are not equivalent. return +a === +b; &#125; if (typeof a != &apos;object&apos; || typeof b != &apos;object&apos;) return false; // Assume equality for cyclic structures. The algorithm for detecting cyclic // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`. var length = aStack.length; while (length--) &#123; // Linear search. Performance is inversely proportional to the number of // unique nested structures. if (aStack[length] === a) return bStack[length] === b; &#125; // Objects with different constructors are not equivalent, but `Object`s // from different frames are. var aCtor = a.constructor, bCtor = b.constructor; if ( aCtor !== bCtor &amp;&amp; // Handle Object.create(x) cases &apos;constructor&apos; in a &amp;&amp; &apos;constructor&apos; in b &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor instanceof aCtor &amp;&amp; _.isFunction(bCtor) &amp;&amp; bCtor instanceof bCtor) ) &#123; return false; &#125; // Add the first object to the stack of traversed objects. aStack.push(a); bStack.push(b); var size, result; // Recursively compare objects and arrays. if (className === &apos;[object Array]&apos;) &#123; // Compare array lengths to determine if a deep comparison is necessary. size = a.length; result = size === b.length; if (result) &#123; // Deep compare the contents, ignoring non-numeric properties. while (size--) &#123; if (!(result = eq(a[size], b[size], aStack, bStack))) break; &#125; &#125; &#125; else &#123; // Deep compare objects. var keys = _.keys(a), key; size = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality. result = _.keys(b).length === size; if (result) &#123; while (size--) &#123; // Deep compare each member key = keys[size]; if (!(result = _.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) break; &#125; &#125; &#125; // Remove the first object from the stack of traversed objects. aStack.pop(); bStack.pop(); return result;&#125;; // Perform a deep comparison to check if two objects are equal._.isEqual = function(a, b) &#123; return eq(a, b, [], []);&#125;;"},{"title":"将一个JS数组乱序输出","date":"2019-10-30T04:23:45.000Z","path":"2019/10/30/blog-003/","text":"在Javascript可能有这样的需求：将一个数组乱序输出，推荐两种方法。 1、splice()方法 123456789function shuffle(a) &#123; var arr = []; while (a.length &gt; 0) &#123; var i= parseInt(Math.random() * (a.length - 1)); arr.push(a[i]); a.splice(i, 1); &#125; return arr;&#125; 2、洗牌法 效率高 12345678910function shuffle(a) &#123; var len = a.length; for (var i = 0; i &lt; len - 1; i++) &#123; var index = parseInt(Math.random() * (len - i)); var temp = a[index]; a[index] = a[len - i - 1]; a[len - i - 1] = temp; &#125; return a;&#125;"},{"title":"JS中call、apply、bind三者的作用和区别","date":"2019-10-30T03:05:46.000Z","path":"2019/10/30/blog-002/","text":"在刚接触javascript时，就碰到call(),apply(),bind()，我一直不是很明白。在工作中接触它们次数多了，对这三个方法也有了点理解，总的就是一句话：三者的作用都是改变函数的执行上下文。今天把它们简单阐述一下！ JavaScript权威指南上的解释是： call() 、apply()可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。我理解它们的作用是：都能继承另一个对象的方法和属性。bind() 就是将某个函数(属性或方法)绑定到某个对象上。 12345var obj = &#123;name: &quot;Tom&quot;&#125;function foo() &#123;console.log(this.name)&#125;foo.call(obj) //打印结果： Tom this 指向 指定的对象（obj） 1.call() 和 apply() 的第一个参数都是指定的对象。这个对象就是该函数的执行上下文2.call() 和 apply() 的区别：两者之间的参数不同 - call() 在第一个参数之后的 后续所有参数就是传入该函数的值（形参）。 - apply() 只有两个参数，第一个是指定的对象，第二个是数组，这个数组的每一个元素都是该函数的参数（形参）。 12345678910// call()函数var obj = &#123; message: &apos;My name is: &apos;&#125;function getName(firstName, lastName) &#123; console.log(this.message + firstName);&#125;getName.call(obj, &apos;Tom&apos;, &apos;Jorry&apos;) // My name is: Tom this 指向 指定的对象（obj） 123456789101112// apply() 函数var obj = &#123; message: &apos;My name is: &apos;&#125;function getName(firstName, lastName) &#123; console.log(this.message + firstName);&#125;getName.apply(obj, [&apos;Tom&apos;, &apos;Jorry&apos;]) // My name is: Tom 传参 是一个数组// this 指向 指定的对象（obj） bind() 它的参数和call()相同。它和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。"},{"title":"几款免费开放的接口API","date":"2019-10-29T10:04:38.000Z","path":"2019/10/29/blog-001/","text":"前端开发者经常面对五花八门的技术，通常为了更好的适应潮流需要学习和实战。但是实战演练过程中往往因为没有后端开发配合，演练总会有不足之处…那就是接口，接口，接口！下面为大家推荐几个开放的API接口地址 小白接口小白接口特点： 接口全面，速度快 能自己建模，调用属于自己的接口 官方人员在线给予技术支持，响应速度超快 免费 免费 免费！ 非常适合前端开发学习使用！强烈推荐！强烈推荐！强烈推荐！ 小白地址 http://open.yesapi.cn/?r=user/registration&amp;from=January 技术QQ群： 660311764 API工厂API工厂特点就是接口全面，速度也不错唯一缺点就是：有些功能必须花钱总体来说值得推荐 接口文档地址：https://api.it120.cc/doc.html 后台管理地址：https://admin.it120.cc/ 其他还有一些开发接口，不过因为各种原因用起来比较麻烦 apiopen ：https://www.apiopen.top 豆瓣API 貌似挂啦 看着篇就够了：https://blog.csdn.net/qq_31754523/article/details/94665791 Mock.js会用mockjs搞数据的就用mock吧，各有利弊，看个人习惯 Mock.js: http://mockjs.com/"}]